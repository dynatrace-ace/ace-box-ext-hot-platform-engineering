---

#
# Setting some global facts!
- set_fact:
    dt_tenant_no_protocol: "{{ dynatrace_tenant_url | regex_search('[^\/\/]*$') }}"

- set_fact:
    tenant_id: "{{ dt_tenant_no_protocol | split('.') }}"

- set_fact:
    usecase_source: "{{ role_path }}/files"
    usecase_dest: "{{ role_path }}/gitlabfiles"

- debug:
    msg: | 
      "Platform Engineering HoT automated provisioning started..."
      "tenant_id: {{ tenant_id }}"
      "usecase_source: {{ usecase_source }}"
      "usecase_dest: {{ usecase_dest }}"

#
# Install K3s
- include_role:
    name: k3s

#
# Install Dynatrace Operator
- include_role:
    name: dt-operator

#
# Install the OTel Collector
- include_role:
    name: otel-collector

#
# Install GitLab
- include_role:
    name: gitlab

- include_role:
    name: private-registry

#
# Create the default group1 group
- name: Gitlab - Ensure Group
  include_role:
    name: gitlab
    tasks_from: ensure-group
  vars:
    gitlab_group_name: "{{ gitlab_group }}"

- name: Gitlab - Ensure Default Group Vars
  include_role:
    name: gitlab
    tasks_from: ensure-default-group-vars
  vars:
    gitlab_group_name: "{{ gitlab_group }}"

#
# Create GitLab Projects: Backstage Template, App Template & Platform
- name: Gitlab - Ensure Backstage Template Project
  include_role:
    name: gitlab
    tasks_from: ensure-project
  vars:
    gitlab_prj: "{{ gitlab_backstage_template_repo_name }}"
    gitlab_prj_namespace_id: "{{ gitlab_group_id }}"

- name: Gitlab - Ensure App Template Project
  include_role:
    name: gitlab
    tasks_from: ensure-project
  vars:
    gitlab_prj: "{{ gitlab_app_template_repo_name }}"
    gitlab_prj_namespace_id: "{{ gitlab_group_id }}"

- name: Gitlab - Ensure Platform Project
  include_role:
    name: gitlab
    tasks_from: ensure-project
  vars:
    gitlab_prj: "{{ gitlab_platform_repo_name }}"
    gitlab_prj_namespace_id: "{{ gitlab_group_id }}"    

- include_role:
    name: gitlab
    tasks_from: source-endpoints-external
  when: gitlab_external_endpoint is not defined

- include_role:
    name: gitlab
    tasks_from: source-secret
  when: gitlab_personal_access_token is not defined or gitlab_username is not defined or gitlab_password is not defined

- name: Gitlab - Additional Environment Variables
  include_role:
    name: gitlab
    tasks_from: ensure-group-var
  vars:
    gitlab_var_key: "{{ item.key }}"
    gitlab_var_value: "{{ item.value }}"
  loop:
    - {
        key: "DT_PLATFORM_TENANT_URL",
        value: "{{ extra_vars.dt_environment_url_gen3.rstrip('/') }}",
      }
    - {
        key: "DT_OAUTH_CLIENT_ID",
        value: "{{ extra_vars.dt_oauth_client_id }}",
      }
    - {
        key: "DT_OAUTH_CLIENT_SECRET",
        value: "{{ extra_vars.dt_oauth_client_secret }}",
      }
    - {
        key: "DT_OAUTH_SSO_ENDPOINT",
        value: "{{ extra_vars.dt_oauth_sso_endpoint.rstrip('/') }}",
      }
    - {
        key: "DT_OAUTH_ACCOUNT_URN",
        value: "{{ extra_vars.dt_oauth_account_urn }}",
      }
    - { key: "GITLAB_USERNAME", value: "{{ gitlab_username }}" }
    - { key: "GITLAB_PASSWORD", value: "{{ gitlab_password }}" }
    - {
        key: "GITLAB_PRIVATE_TOKEN",
        value: "{{ gitlab_personal_access_token }}",
      }
    - {
        key: "GITLAB_EXTERNAL_ENDPOINT",
        value: "{{ gitlab_external_endpoint }}",
      }
    - { key: "DEMO_IDENTIFIER", value: "{{ demo_identifier }}" }

- name: Source Gitlab endpoint
  include_role:
    name: gitlab
    tasks_from: source-endpoints    

#
# Copy all files for the 3 GitLab Repos from files to gitlabfiles
# > then replace PLACEHOLDERS
# > then upload to gitlab
- name: Delete Git repo files
  ansible.builtin.file:
    path: "{{ usecase_dest }}/"
    state: absent

- name: Copy Git repo files
  ansible.builtin.copy:
    src: "{{ usecase_source }}/"
    dest: "{{ usecase_dest }}/"
    force: true
    remote_src: yes
    directory_mode: "u+rwx"

- set_fact:    
    gitlab_repo_base_url: "{{ gitlab_external_endpoint }}/{{ gitlab_group }}"
    apptemplates_dest: "{{ usecase_dest }}/apptemplates"
    backstagetemplates_dest: "{{ usecase_dest }}/backstagetemplates"
    platform_dest: "{{ usecase_dest }}/platform"    

- name: Replace PLACEHOLDERS for template files in git
  shell: |
    pwd
    cd {{ usecase_dest }}
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#GEOLOCATION_PLACEHOLDER#{{ dynatrace_geolocation }}#g" {} \;
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#DT_TENANT_LIVE_PLACEHOLDER#{{ dynatrace_tenant_url }}#g" {} \;
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#DT_TENANT_APPS_PLACEHOLDER#{{ extra_vars.dt_environment_url_gen3 }}#g" {} \;
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#BASE_DOMAIN_PLACEHOLDER#{{ ingress_domain }}#g" {} \;
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#FORKED_TEMPLATE_REPO_PLACEHOLDER#{{ gitlab_repo_base_url }}/platform#g" {} \;
    find . -type f \( -not -path '*/\.*' -not -iname "README.md" \) -exec sed -i "s#PROTOCOL_PLACEHOLDER#{{ ingress_protocol }}#g" {} \;

- name: Publish to Gitlab
  block:
    - name: Publish apptemplates to Gitlab
      include_role:
        name: repository
      ignore_errors: yes
      vars:
        git_username: "root"
        git_password: "{{ gitlab_password }}"
        git_domain: "{{ gitlab_domain }}"
        git_remote: "gitlab"
        git_org: "{{ gitlab_group }}"
        git_repo: "{{ gitlab_app_template_repo_name }}"
        repo_src: "{{ apptemplates_dest }}"
    - name: Publish Backstage Templates
      include_role:
        name: repository
      ignore_errors: yes
      vars:
        git_username: "root"
        git_password: "{{ gitlab_password }}"
        git_domain: "{{ gitlab_domain }}"
        git_remote: "gitlab"
        git_org: "{{ gitlab_group }}"
        git_repo: "{{ gitlab_backstage_template_repo_name }}"
        repo_src: "{{ backstagetemplates_dest }}"
    - name: Publish Platform to Gitlab
      include_role:
        name: repository
      ignore_errors: yes
      vars:
        git_username: "root"
        git_password: "{{ gitlab_password }}"
        git_domain: "{{ gitlab_domain }}"
        git_remote: "gitlab"
        git_org: "{{ gitlab_group }}"
        git_repo: "{{ gitlab_platform_repo_name }}"
        repo_src: "{{ platform_dest }}"
  rescue:
    - name: Rescue Message
      debug:
        msg: "GitLab Upload failed but we are continuing"

#
# Now lets install ArgoCD
- include_role:
    name: argocd-andi

- name: Create Argo Config Map to define user Alice for API Access
  kubernetes.core.k8s:
    state: present
    definition:
      kind: ConfigMap
      metadata:
        name: argocd-cm
        namespace: argocd
        labels:
          app.kubernetes.io/name: argocd-cm
          app.kubernetes.io/part-of: argocd
      data:
        accounts.alice: apiKey, login
        accounts.alice.enabled: "true"
        statusbadge.enabled: "true"
        context: |
          argocdUrl: "https://argo.{{ ingress_domain }}"        

- name: Install ArgoCD CLI
  shell: |
    wget -O argocd https://github.com/argoproj/argo-cd/releases/download/v2.10.5/argocd-linux-amd64
    chmod +x argocd
    sudo mv argocd /usr/bin
    argocd login argo --core

# - name: Get ArgoCD Token
#   shell: argocd account generate-token --account alice
#   register: argocd_token


#
# Lets create some secrets that tools like Backstage, Argo Workflows ... need
# NEEDS TO HAPPEN BEFORE ArgoCD deploys our platform
- name: Create Backstage namespace
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: backstage

- name: Create Backstage Secret
  kubernetes.core.k8s:
    name: "backstage-secrets"
    api_version: v1
    kind: Secret
    state: present
    namespace: "backstage"
    resource_definition:
      type: Opaque
      data:
        GITLAB_TOKEN: "{{ gitlab_personal_access_token | b64encode }}"
#        ARGOCD_TOKEN: "{{ argocd_token }}"
        DT_TENANT_LIVE: "{{ dynatrace_tenant_url | b64encode }}"
        DT_TENANT_APPS: "{{ extra_vars.dt_environment_url_gen3 | b64encode }}"
        DT_EVENT_INGEST_TOKEN: "{{ dynatrace_api_token | b64encode }}"
        DT_TENANT_NAME: "{{ tenant_id[0] | b64encode }}"
        DT_CLIENT_ID: "{{ extra_vars.dt_oauth_client_id | b64encode }}"
        DT_CLIENT_SECRET: "{{ extra_vars.dt_oauth_client_secret | b64encode }}"
        DT_ACCOUNT_URN: "{{ extra_vars.dt_oauth_account_urn | b64encode }}"

- name: Create Dynatrace namespace
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: dynatrace

- name: Create Dynatrace Secret
  kubernetes.core.k8s:
    name: "dt-bizevent-oauth-details"
    api_version: v1
    kind: Secret
    state: present
    namespace: "dynatrace"
    resource_definition:
      type: Opaque
      data:
        TENANT_URL: "{{ dynatrace_tenant_url | b64encode }}"
        OAUTH_CLIENT_ID: "{{ extra_vars.dt_oauth_client_id | b64encode }}"
        OAUTH_CLIENT_SECRET: "{{ extra_vars.dt_oauth_client_secret | b64encode }}"
        ACCOUNT_URN: "{{ extra_vars.dt_oauth_account_urn | b64encode }}"

- name: Create Monaco namespace
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: monaco

- name: Create Monaco Secret
  kubernetes.core.k8s:
    name: "monaco-secret"
    api_version: v1
    kind: Secret
    state: present
    namespace: "monaco"
    resource_definition:
      type: Opaque
      data:
        DT_MONACO_TOKEN: "{{ dynatrace_api_token | b64encode }}"


#output = run_command(["kubectl", "-n", "dynatrace", "create", "secret", "generic", "dt-bizevent-oauth-details", f"--from-literal=dtTenant={DT_TENANT_LIVE}", f"--from-literal=oAuthClientID={DT_OAUTH_CLIENT_ID}", f"--from-literal=oAuthClientSecret={DT_OAUTH_CLIENT_SECRET}", f"--from-literal=accountURN={DT_OAUTH_ACCOUNT_URN}"])
# output = run_command(["kubectl", "-n", "opentelemetry", "create", "secret", "generic", "dt-bizevent-oauth-details", f"--from-literal=dtTenant={DT_TENANT_LIVE}", f"--from-literal=oAuthClientID={DT_OAUTH_CLIENT_ID}", f"--from-literal=oAuthClientSecret={DT_OAUTH_CLIENT_SECRET}", f"--from-literal=accountURN={DT_OAUTH_ACCOUNT_URN}"])
#output = run_command(["kubectl", "-n", "argocd", "create", "secret", "generic", "argocd-notifications-secret", f"--from-literal=dynatrace-url={DT_TENANT_LIVE}", f"--from-literal=dynatrace-token={DT_ALL_INGEST_TOKEN}"])
#output = run_command(["kubectl", "-n", "monaco", "create", "secret", "generic", "monaco-secret", f"--from-literal=monacoToken={DT_MONACO_TOKEN}"])
#output = run_command(["kubectl", "-n", "dynatrace", "create", "secret", "generic", "monaco-secret", f"--from-literal=monacoToken={DT_MONACO_TOKEN}"])


#
# This will connect ArgoCD to the GitLab Platform Repo
# ArgoCD will find the Platform Definition and will start to deploy the Platform (Backstage, Workflows ...)
- name: Connect ArgoCD to GitLab Platform Repo
  include_role:
    name: argocd-andi
    tasks_from: ensure-gitlab-application-set
  vars:
    argocd_appset_repositorymatch: "platform"
    argocd_gitlab_generator_k8s_path: "applications/platform"
    argocd_gitlab_generator_owner: "group1"


- include_role:
    name: dashboard